
DEFINE_PATCH_FUNCTION CREATE_B_BCS_NAME
	STR_VAR
		namez  = ""
		prefix = ""
		suffix = ""
	RET
		result
BEGIN
	SPRINT ~result~ ~%prefix%%namez%~
	SET lng  = STRING_LENGTH ~%result%~
	SET lngs = STRING_LENGTH ~%suffix%~
	PATCH_IF ( lng > 8 ) BEGIN SNPRINT 8 ~result~ ~%result%~ END
	PATCH_IF ( lngs > 0 ) BEGIN
		SET zzz = 8 - lngs
		SNPRINT zzz ~result~ ~%result%~
		SPRINT ~result~ ~%result%%suffix%~
	END
END

DEFINE_ACTION_FUNCTION CREATE_B_BCS_NAME
	INT_VAR
		mx_lng = 8
	STR_VAR
		namez  = ""
		prefix = ""
		suffix = ""
	RET
		result
BEGIN
	OUTER_SPRINT ~result~ ~%prefix%%namez%~
	OUTER_SET lng  = STRING_LENGTH ~%result%~
	OUTER_SET lngs = STRING_LENGTH ~%suffix%~
	ACTION_IF ( lng > mx_lng ) BEGIN OUTER_SNPRINT mx_lng ~result~ ~%result%~ END
	ACTION_IF ( lngs > 0 ) BEGIN
		OUTER_SET zzz = mx_lng - lngs
		OUTER_SNPRINT zzz ~result~ ~%result%~
		OUTER_SPRINT ~result~ ~%result%%suffix%~
	END
END

DEFINE_ACTION_FUNCTION repl_textscreen_2da
	INT_VAR strr = "-1" rws = 2 nums = 3
	STR_VAR file = ""
BEGIN
	COPY_EXISTING ~%file%.2da~ ~override~
		SET_2DA_ENTRY 1 ~%rws%~ ~%nums%~ ~%strr%~
		PRETTY_PRINT_2DA
END

//BLOCK TO_HEX_NUMBER
DEFINE_ACTION_FUNCTION TO_HEX_NUMBER
INT_VAR
  value     = 0   // the decimal number
  minDigits = 1   // min. number of digits in return value (not counting sign)
  prefix    = 0   // whether to return number with "0x" prefix
RET
  hexNumber       // returned as string without prefix
BEGIN
  ACTION_IF (minDigits < 1) BEGIN OUTER_SET minDigits = 1 END
  ACTION_IF (minDigits > 8) BEGIN OUTER_SET minDigits = 8 END
  OUTER_TEXT_SPRINT hexNumber ~~
  ACTION_DEFINE_ARRAY digit BEGIN ~0~ ~1~ ~2~ ~3~ ~4~ ~5~ ~6~ ~7~ ~8~ ~9~ ~a~ ~b~ ~c~ ~d~ ~e~ ~f~ END

  ACTION_IF (value < 0) BEGIN
    OUTER_SET signed = 1
    OUTER_SET value = 0 - value
  END ELSE BEGIN
    OUTER_SET signed = 0
  END

  OUTER_WHILE (value != 0) BEGIN
    OUTER_SET curDigit = value BAND 0xf
    OUTER_SET value = value BLSR 4
    OUTER_TEXT_SPRINT hexDigit $EVAL digit(~%curDigit%~)
    OUTER_TEXT_SPRINT hexNumber ~%hexDigit%%hexNumber%~
  END

  OUTER_WHILE (STRING_LENGTH ~%hexNumber%~ < minDigits) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~0%hexNumber%~
  END

  ACTION_IF (prefix) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~0x%hexNumber%~
  END

  ACTION_IF (signed) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~-%hexNumber%~
  END
END

DEFINE_PATCH_FUNCTION TO_HEX_NUMBER
INT_VAR
  value     = 0
  minDigits = 1
  prefix    = 0
RET
  hexNumber
BEGIN
  INNER_ACTION BEGIN
    LAF TO_HEX_NUMBER INT_VAR value = value minDigits = minDigits prefix = prefix RET hexNumber END
  END
END
//BLOCKEND
/*DEFINE_ACTION_FUNCTION ADD_SPLPROT_ENTRY
STR_VAR
  label       = ~~  // optional entry label (value of first column)
  definition  = ~~  // definition without label
RET
  index             // returns -1 if entry could not be added
BEGIN
  OUTER_SET index = "-1"
  ACTION_IF (NOT ~%definition%~ STR_EQ ~~) BEGIN
    COPY_EXISTING ~splprot.2da~ ~override~
      COUNT_2DA_COLS numCols
      PATCH_IF (numCols = 4) BEGIN
        READ_2DA_ENTRIES_NOW table numCols
        // use existing entry if available
        FOR (row = 0; row < table; ++row) BEGIN
          READ_2DA_ENTRY_FORMER table row 1 stat
          PATCH_IF (~%stat%~ STRING_COMPARE_REGEXP ~[*+]~ = 0) BEGIN TEXT_SPRINT stat ~\%stat%~ END
          READ_2DA_ENTRY_FORMER table row 2 value
          PATCH_IF (~%value%~ STRING_COMPARE_REGEXP ~[*+]~ = 0) BEGIN TEXT_SPRINT value ~\%value%~ END
          READ_2DA_ENTRY_FORMER table row 3 rel
          PATCH_IF (~%rel%~ STRING_COMPARE_REGEXP ~[*+]~ = 0) BEGIN TEXT_SPRINT rel ~\%rel%~ END
          TEXT_SPRINT regexp ~[ %TAB%]+%stat%[ %TAB%]+%value%[ %TAB%]+%rel%[ %TAB%]*~
          PATCH_IF (~%definition%~ STRING_COMPARE_REGEXP ~%regexp%~ = 0) BEGIN
            SET index = row
            SET row = table
          END
        END

        // add new definition if needed
        PATCH_IF (index < 0) BEGIN
          SET index = table
          PATCH_IF (~%label%~ STR_EQ ~~) BEGIN TEXT_SPRINT label ~%index%~ END
          PATCH_IF (STRING_LENGTH ~%label%~ < 11) BEGIN
            TEXT_SPRINT label ~%label%          ~
            INNER_PATCH_SAVE label ~%label%~ BEGIN DELETE_BYTES 10 (BUFFER_LENGTH - 10) END
          END
          INSERT_2DA_ROW index numCols ~%label% %definition%~
        END
      END
    BUT_ONLY IF_EXISTS
  END
END*/
//BLOCK ADD_SPLPROT_ENTRY
DEFINE_ACTION_FUNCTION ADD_SPLPROT_ENTRY
	INT_VAR
		stat_hex    = 1
		value_hex   = 0
	STR_VAR
		label       = ~~
		definition  = ~~
	RET
		index
		exists
		label1
BEGIN
	OUTER_SET index  = "-1"
	OUTER_SET exists =   0
	ACTION_IF (NOT ~%definition%~ STR_EQ ~~) BEGIN
		//extract definition
		OUTER_SPRINT ~stat~ ~~
		OUTER_SPRINT ~value~ ~~
		OUTER_SPRINT ~rel~ ~~
		OUTER_INNER_PATCH_SAVE definition ~%definition%~ BEGIN
			REPLACE_TEXTUALLY ~[ %TAB%]~ ~*~
			SET lng  = BUFFER_LENGTH
			SET true = 1
			SET cmp  = 0
			FOR ( i = 0 ; i < lng ; ++i ) BEGIN
				READ_ASCII i z (1)
				PATCH_IF ( ~%z%~ STR_CMP ~*~ ) BEGIN
					PATCH_IF ( true = 1 ) BEGIN
						PATCH_MATCH cmp WITH
							0 BEGIN SPRINT ~stat~  ~%stat%%z%~ END
							1 BEGIN SPRINT ~value~ ~%value%%z%~ END
							2 BEGIN SPRINT ~rel~   ~%rel%%z%~ END
						DEFAULT
						END
					END ELSE BEGIN
						SET true = 1
						SET cmp = cmp + 1
						PATCH_MATCH cmp WITH
							0 BEGIN SPRINT ~stat~  ~%stat%%z%~ END
							1 BEGIN SPRINT ~value~ ~%value%%z%~ END
							2 BEGIN SPRINT ~rel~   ~%rel%%z%~ END
						DEFAULT
						END
					END
				END ELSE BEGIN
					SET true = 0
				END
			END
		END
		OUTER_SET stat  =  ~%stat%~
		OUTER_SET value = ~%value%~
		OUTER_SET rel   =   ~%rel%~
		COPY_EXISTING ~splprot.2da~ ~override~
			COUNT_2DA_ROWS 4 table
			//find existing entry
			FOR ( i = 0 ; i < table ; ++i ) BEGIN
				SET true = 0
				READ_2DA_ENTRY i 0 4 label1
				READ_2DA_ENTRY i 1 4 stat1
				PATCH_IF ( IS_AN_INT ~stat1~ )  AND ( stat = stat1 )   BEGIN true = true + 1 END
				READ_2DA_ENTRY i 2 4 value1
				PATCH_IF ( IS_AN_INT ~value1~ ) AND ( value = value1 ) BEGIN true = true + 1 END
				READ_2DA_ENTRY i 3 4 rel1
				PATCH_IF ( IS_AN_INT ~rel1~ )   AND ( rel = rel1 )     BEGIN true = true + 1 END
				PATCH_IF ( true = 3 ) BEGIN
					SET index = i
					SET exists = 1
					SET i = table
					TEXT_SPRINT ~label1~ ~%label1%	%stat1%	%value1%	%rel1%~
				END
			END
			//add_new_string
			PATCH_IF ( index < 0 ) BEGIN
				SET index = table
				PATCH_IF (~%label%~ STR_EQ ~~) BEGIN TEXT_SPRINT label ~%index%~ END
				PATCH_IF ( stat >= 0 ) AND ( stat_hex = 1 ) BEGIN
					LPF TO_HEX_NUMBER INT_VAR value=stat minDigits=3 prefix=1 RET stat=hexNumber END
				END
				PATCH_IF ( value >= 0 ) AND ( value_hex = 1) BEGIN
					LPF TO_HEX_NUMBER INT_VAR value=value prefix=1 RET value=hexNumber END
				END
				TEXT_SPRINT ~label1~ ~%label%	%stat%	%value%	%rel%~
				INSERT_2DA_ROW index 4 ~%label1%~
				PRETTY_PRINT_2DA
			END
			BUT_ONLY_IF_IT_CHANGES
			IF_EXISTS
	END
END
//BLOCKEND

// Animation slots reserved by vanilla or mod-added game creatures (in hexadecimal format)
// Supported mods:
// - Bearwalker + extended Werebear animation
// - Pack Mule
<<<<<<<< .../inlined/creature/animation/slots.txt
"0410" "1000" "1003" "1004" "1100" "1101" "1102" "1103" "1104" "1105" "1200" "1201" "1202" "1203" "1204" "1205" "1206" "1207" "1208" "1300" "2000" "2100" "2200" "2300" "3000" "3001" "4000" "4001" "4002" "4010" "4012" "4100" "4101" "4102" "4110" "4112" "4200" "4300" "4400" "4410" "4500" "4600" "4700" "4710" "4800" "5000" "5001" "5002" "5003" "5010" "5011" "5012" "5013" "5100" "5101" "5102" "5103" "5110" "5111" "5112" "5113" "5200" "5201" "5202" "5210" "5211" "5212" "5300" "5301" "5302" "5303" "5310" "5311" "5312" "5313" "6000" "6001" "6002" "6003" "6004" "6005" "6010" "6011" "6012" "6013" "6014" "6015" "6100" "6101" "6102" "6103" "6104" "6105" "6110" "6111" "6112" "6113" "6114" "6115" "6200" "6201" "6202" "6204" "6205" "6210" "6211" "6212" "6214" "6215" "6300" "6301" "6302" "6303" "6304" "6305" "6310" "6311" "6312" "6313" "6314" "6315" "6400" "6401" "6402" "6403" "6404" "6405" "6406" "6500" "6510" "6621" "7000" "7001" "7100" "7101" "7200" "7201" "7202" "7203" "7300" "7301" "7302" "7310" "7311" "7312" "7313" "7314" "7320" "7321" "7400" "7401" "7402" "7500" "7501" "7600" "7601" "7602" "7603" "7604" "7700" "7701" "7702" "7703" "7800" "7801" "7802" "7900" "7901" "7902" "7903" "7904" "7a00" "7a01" "7a02" "7a03" "7a04" "7b00" "7b01" "7b02" "7b03" "7b04" "7b05" "7b06" "7c00" "7c01" "7d00" "7d01" "7d02" "7d03" "7d04" "7d05" "7d06" "7d07" "7d08" "7e00" "7e01" "7f00" "7f01" "7f02" "7f03" "7f04" "7f05" "7f06" "7f07" "7f08" "7f09" "7f0a" "7f0b" "7f0c" "7f0d" "7f0e" "7f0f" "7f10" "7f11" "7f12" "7f13" "7f14" "7f15" "7f16" "7f17" "7f18" "7f19" "7f20" "7f21" "7f22" "7f23" "7f24" "7f27" "7f28" "7f29" "7f2a" "7f2b" "7f2c" "7f2d" "7f2e" "7f2f" "7f30" "7f31" "7f32" "7f33" "7f34" "7f35" "7f36" "7f37" "7f38" "7f39" "7f3a" "7f3b" "7f3c" "7f3d" "7f3e" "7f3f" "7f40" "7f41" "7f42" "7f43" "7f44" "7f45" "7f46" "7f47" "7f48" "7f49" "7f4a" "7f4b" "7f4c" "7f4d" "7f4e" "7f4f" "7f50" "7f51" "7f52" "7f53" "7f54" "7f55" "7f56" "7f57" "7f58" "7f59" "7f5a" "7f5b" "7f5c" "7f5d" "7f5e" "7f5f" "7f60" "7f61" "7f62" "8000" "8100" "8200" "9000" "a000" "a100" "a200" "a201" "a202" "b000" "b100" "b200" "b210" "b300" "b310" "b400" "b410" "b500" "b510" "b600" "b610" "b700" "c000" "c100" "c200" "c300" "c400" "c500" "c600" "c610" "c700" "c710" "c800" "c810" "c900" "c910" "ca00" "ca10" "cb00" "cc00" "cc01" "cc02" "cc04" "d000" "d100" "d200" "d300" "d400" "e000" "e010" "e020" "e040" "e050" "e060" "e070" "e080" "e090" "e0a0" "e0b0" "e0c0" "e0d0" "e0e0" "e0f0" "e0f1" "e0f2" "e200" "e210" "e220" "e230" "e240" "e241" "e242" "e243" "e244" "e245" "e246" "e247" "e248" "e249" "e24a" "e24b" "e24c" "e24d" "e24e" "e24f" "e250" "e251" "e252" "e253" "e254" "e255" "e256" "e257" "e258" "e259" "e25a" "e25b" "e25c" "e25d" "e25e" "e25f" "e260" "e261" "e262" "e263" "e264" "e265" "e266" "e267" "e26a" "e26b" "e26d" "e26e" "e26f" "e270" "e271" "e272" "e273" "e274" "e276" "e279" "e27d" "e27e" "e27f" "e280" "e281" "e282" "e283" "e288" "e289" "e28a" "e28b" "e28c" "e28d" "e28e" "e28f" "e290" "e291" "e292" "e293" "e294" "e300" "e310" "e320" "e330" "e400" "e410" "e420" "e430" "e440" "e441" "e442" "e443" "e444" "e500" "e510" "e520" "e600" "e610" "e6fe" "e700" "e710" "e720" "e800" "e810" "e820" "e830" "e840" "e900" "e910" "ea00" "ea10" "ea20" "eb00" "eb10" "eb20" "ec00" "ec10" "ec20" "ed00" "ed10" "ed20" "ee00" "ee10" "ef10"
>>>>>>>>
OUTER_TEXT_SPRINT animationSlotsPath ".../inlined/creature/animation/slots.txt"

/** FREE_ANIM_SLOT
 * Returns the first free creature animation slot in the range defined by slotMin and slotMax.
 * INT_VAR slotMin    Lowest available creature animation slot for the animation.
 * INT_VAR slotMax    Highest available creature animation slot for the animation.
 * INT_VAR slotSteps  How many slots to skip after each iteration, starting from slotMin.
 *                    Setting this parameter is useful if compatible animation slots are always
 *                    a fixed distance apart (e.g. at a distance of 0x10 each)
 * RET slot           A free animation slot. Returns -1 if none found.
 */
DEFINE_ACTION_FUNCTION FIND_FREE_ANIM_SLOT
INT_VAR
  slotMin   = 0
  slotMax   = (slotMin BAND 0xf000) + 0x1000
  slotSteps = 1
RET
  slot
BEGIN
  OUTER_SET slot = "-1"
  ACTION_IF (slotSteps < 1) BEGIN OUTER_SET slotSteps = 1 END
  ACTION_IF (slotMin < 0) BEGIN OUTER_SET slotMin = 0 END
  ACTION_IF (slotMax < 0) BEGIN OUTER_SET slotMax = 0 END
  ACTION_IF (slotMax < slotMin) BEGIN
    OUTER_SET tmp = slotMin
    OUTER_SET slotMin = slotMax
    OUTER_SET slotMax = tmp
  END

  // animslots.txt contains reserved creature animation slots
  COPY - ~%animationSlotsPath%~ ~%animationSlotsPath%~
    READ_ASCII 0 slotList (SOURCE_SIZE)
    FOR (idx = slotMin; idx < slotMax; idx += slotSteps) BEGIN
      LOOKUP_IDS_SYMBOL_OF_INT name ~animate~ idx
      PATCH_IF (~%name%~ STRING_EQUAL ~%idx%~) BEGIN
        LPF TO_HEX_NUMBER INT_VAR value = idx minDigits = 4 RET hexNumber END
        PATCH_IF (NOT FILE_EXISTS_IN_GAME ~%hexNumber%.ini~ AND
                  ~%slotList%~ STRING_CONTAINS_REGEXP ~"%hexNumber%"~ != 0) BEGIN
          SET slot = idx
          SET idx = slotMax
        END
      END
    END
END

DEFINE_PATCH_FUNCTION FIND_FREE_ANIM_SLOT
INT_VAR
  slotMin   = 0
  slotMax   = (slotMin BAND 0xf000) + 0x1000
  slotSteps = 1
RET
  slot
BEGIN
  INNER_ACTION BEGIN
    LAF FIND_FREE_ANIM_SLOT INT_VAR slotMin = slotMin slotMax = slotMax slotSteps = slotSteps RET slot END
  END
END

// Adds a new entry for a conversable item
DEFINE_PATCH_FUNCTION ADD_ITEM_DIALOG
INT_VAR
  button_strref = 5689  // Default: "Converse"
  name_strref   = "-1"  // not used outside of PSTEE
STR_VAR
  itm_resref    = ~~
  dlg_resref    = ~~
BEGIN
  PATCH_IF (NOT ~%itm_resref%~ STR_EQ ~~) BEGIN
    PATCH_IF (~%dlg_resref%~ STR_EQ ~~) BEGIN TEXT_SPRINT dlg_resref ~%itm_resref%~ END
    COUNT_2DA_COLS numCols
    COUNT_2DA_ROWS numCols numRows
    TEXT_SPRINT entry ~%itm_resref%      %button_strref%  %dlg_resref%~
    PATCH_IF (numCols > 3) BEGIN
      TEXT_SPRINT entry ~%entry% %name_strref%~
      FOR (idx = 4; idx < numCols; ++idx) BEGIN TEXT_SPRINT entry ~%entry% *~ END
    END
    INSERT_2DA_ROW numRows numCols ~%entry%~
  END
END


//BLOCK REPLACE_MULTILINE
//Patch function that replaces set or all occurrences of the given regexp pattern in the file with the given string.
//Use EVAL to perform variable substitution on the string and/or the regexp pattern.
//Unlike REPLACE_TEXTUALLY the pattern can be multi-line text, even without using regexp.
//Just like REPLACE_BCS_BLOCK the function ignores pattern whitespace.
//The function can be also used as a COUNT_REGEXP_INSTANCES alternative with the above mentioned features.
//Optional PATCH_WARN message is printed if the task could not be performed (pattern not found or different amount of pattern matches than expected).

DEFINE_PATCH_FUNCTION REPLACE_MULTILINE
	INT_VAR
		num = "-1"     //amount of times the pattern should be replaced with string (-1 by default which is at least 1 but without max limit)
		strict = 0     //set to 1 to enable strict checking (auto escapes $^.*+?[]\ special characters)
		verbose = 1    //set to 0 to skip printing patching message
		warn = 1       //set to 0 to skip printing warning message if the function can't do what you ask it to do
		only_count = 0 //set to to 1 to skip pattern replacing and just return num_matches (COUNT_REGEXP_INSTANCES alternative)
	STR_VAR
		pattern = ""   //pattern that you want to replace
		string = ""    //string that the pattern will be replaced with
	RET
		num_matches    //amount of times the pattern has been found
	BEGIN
	TEXT_SPRINT percent ~%~
	INNER_PATCH_SAVE textToReplace ~%pattern%~ BEGIN
		PATCH_IF strict = 1 BEGIN
			REPLACE_TEXTUALLY ~\\~ ~\\\\~
			REPLACE_TEXTUALLY ~\[~ ~\[~
			REPLACE_TEXTUALLY ~\]~ ~\]~
			REPLACE_EVALUATE ~\([\$\^\.\*\+\?]\)~ BEGIN END ~\%MATCH1%~
		END
		REPLACE_TEXTUALLY ~[%WNL%%LNL%%MNL%%TAB% ]+~ ~[%WNL%%LNL%%MNL%%TAB% ]+~
	END
	SET num_matches = 0
	PATCH_IF only_count = 0 BEGIN
		REPLACE_EVALUATE CASE_INSENSITIVE ~%textToReplace%~ BEGIN
			SET num_matches = num_matches + 1
			INNER_PATCH_SAVE string ~%string%~ BEGIN
				REPLACE_TEXTUALLY ~%percent%MATCH\([0-9]+\)%percent%~ ~%MATCH\1%~
			END
		END ~%string%~
		SET warned = 0
		PATCH_IF num_matches != num BEGIN
			PATCH_IF num_matches = 0 BEGIN
				PATCH_IF warn = 1 BEGIN
					PATCH_WARN ~WARNING %SOURCE_FILESPEC% - pattern not found:%LNL%%pattern%~
				END
				SET warned = 1
			END ELSE PATCH_IF num >= 0 AND (num_matches > num OR num_matches < num) BEGIN
				PATCH_IF warn = 1 BEGIN
					PATCH_WARN ~WARNING %SOURCE_FILESPEC% - pattern replaced %num_matches% time(s) instead of %num%:%LNL%%pattern%~
				END
				SET warned = 1
			END
		END
		PATCH_IF verbose = 1 AND warned = 0 BEGIN
			PATCH_PRINT ~Patching %SOURCE_FILESPEC% - pattern replaced %num_matches% time(s):%LNL%%pattern% => %string%~
		END
	END ELSE BEGIN
		COUNT_REGEXP_INSTANCES ~%textToReplace%~ num_matches
	END
END
//BLOCKEND

/* GET_BIT */
DEFINE_PATCH_FUNCTION GET_BIT
INT_VAR
	number = 0
	nth_bit = 0
RET
	bit_value
BEGIN
	SET bit_value = (number >> nth_bit) & 1
END

/* GET_SCRIPT_BLOCK

 * Returns the first available script block containing the specified search string (as regular expression).
 * INT_VAR start_offset   Optional offset where to start searching. (Default: 0)
 * INT_VAR reverse        Specify zero to apply a forward search, or non-zero to apply a backwards seearch from "start_offset". (Default: 0)
 * STR_VAR search_regexp  The search string as regular expression. Must be non-empty.
 * RET script_block       The full script block as string when found, empty string otherwise.
 * RET start_offset       Start offset of the script block when found, -1 otherwise.
 * RET end_offset         End offset (directly behind closing "END") of the script block when found, -1 otherwise.
  */
DEFINE_PATCH_FUNCTION GET_SCRIPT_BLOCK
INT_VAR
  start_offset  = 0
  reverse       = 0
STR_VAR
  search_regexp = ~~
RET
  script_block
  start_offset
  end_offset
BEGIN
  SET offset = start_offset
  PATCH_IF (offset < 0) BEGIN SET offset = 0 END
  PATCH_IF (offset > BUFFER_LENGTH) BEGIN SET offset = BUFFER_LENGTH END

  TEXT_SPRINT script_block ~~
  SET start_offset = "-1"
  SET end_offset = "-1"

  PATCH_IF (NOT ~%search_regexp%~ STR_EQ ~~) BEGIN
    PATCH_IF (reverse) BEGIN
      SET offset = RINDEX_BUFFER(~%search_regexp%~ offset)
    END ELSE BEGIN
      SET offset = INDEX_BUFFER(~%search_regexp%~ offset)
    END

    PATCH_IF (offset >= 0) BEGIN
      SET ofsStart = RINDEX_BUFFER(~^IF$~ offset)
      PATCH_IF (ofsStart >= 0) BEGIN
        SET ofsEnd = INDEX_BUFFER(~^END$~ offset)
        PATCH_IF (ofsEnd >= 0) BEGIN
          SET ofsEnd += 3
          READ_ASCII ofsStart script_block (ofsEnd - ofsStart)
          SET start_offset = ofsStart
          SET end_offset = ofsEnd
        END
      END
    END
  END
END

//BLOCK FC_UPDETE_AREA_OFFSETS
DEFINE_PATCH_FUNCTION FC_UPDETE_AREA_OFFSETS
	INT_VAR
		num = 1
	STR_VAR
		type = actor //actor 0x110, trigger 0x0c4, spawn 0x0c8, entrance 0x068, container 0x0c0, item 0x014, vertex 0x004, ambient 0x0d4, variable 0x050, door 0x0c8, animation 0x04c, automap 0x034, projectile 0x01c
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	READ_LONG  0x054 aco //actor_off
	READ_LONG  0x05c tro //trigger_off
	READ_LONG  0x060 spo //spawn_off
	READ_LONG  0x068 eno //entrance_off
	READ_LONG  0x070 coo //container_off
	READ_LONG  0x078 ito //item_off
	READ_LONG  0x07c veo //vertex_off
	READ_LONG  0x084 amo //ambient_off
	READ_LONG  0x088 vao //variable_off
	READ_SHORT 0x090 ofo //object_flag_off
	READ_LONG  0x0a0 exo //explored_off
	READ_LONG  0x0a8 doo //door_off
	READ_LONG  0x0b0 ano //animation_off
	READ_LONG  0x0b8 too //tiled_off
	READ_LONG  0x0bc soo //song_off
	READ_LONG  0x0c0 reo //rest_off
	READ_LONG  0x0c4 auo //automap_off
	READ_LONG  0x0cc pro //projectile_off
	PATCH_MATCH ~%type%~ WITH
		~actor~      BEGIN SET size = num * 0x110 SET off = aco END
		~trigger~    BEGIN SET size = num * 0x0c4 SET off = tro END
		~spawn~      BEGIN SET size = num * 0x0c8 SET off = spo END
		~entrance~   BEGIN SET size = num * 0x068 SET off = eno END
		~container~  BEGIN SET size = num * 0x0c0 SET off = coo END
		~item~       BEGIN SET size = num * 0x014 SET off = ito END
		~vertex~     BEGIN SET size = num * 0x004 SET off = veo END
		~ambient~    BEGIN SET size = num * 0x0d4 SET off = amo END
		~variable~   BEGIN SET size = num * 0x050 SET off = vao END
		~door~       BEGIN SET size = num * 0x0c8 SET off = doo END
		~animation~  BEGIN SET size = num * 0x04c SET off = ano END
		~automap~    BEGIN SET size = num * 0x034 SET off = auo END
		~projectile~ BEGIN SET size = num * 0x01c SET off = pro END
		DEFAULT
			SET size = 0
			SET off = 0
	END
	PATCH_IF ( size != 0 ) AND ( off != 0 ) BEGIN
		PATCH_IF ( ~%type%~ STR_CMP ~actor~ )      AND ( aco >= off ) BEGIN WRITE_LONG  0x054 aco + size END
		PATCH_IF ( ~%type%~ STR_CMP ~trigger~ )    AND ( tro >= off ) BEGIN WRITE_LONG  0x05c tro + size END
		PATCH_IF ( ~%type%~ STR_CMP ~spawn~ )      AND ( spo >= off ) BEGIN WRITE_LONG  0x060 spo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~entrance~ )   AND ( eno >= off ) BEGIN WRITE_LONG  0x068 eno + size END
		PATCH_IF ( ~%type%~ STR_CMP ~container~ )  AND ( coo >= off ) BEGIN WRITE_LONG  0x070 coo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~item~ )       AND ( ito >= off ) BEGIN WRITE_LONG  0x078 ito + size END
		PATCH_IF ( ~%type%~ STR_CMP ~vertex~ )     AND ( veo >= off ) BEGIN WRITE_LONG  0x07c veo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~ambient~ )    AND ( amo >= off ) BEGIN WRITE_LONG  0x084 amo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~variable~ )   AND ( vao >= off ) BEGIN WRITE_LONG  0x088 vao + size END
		PATCH_IF                                       ( ofo >= off ) BEGIN WRITE_SHORT 0x090 ofo + size END
		PATCH_IF                                       ( exo >= off ) BEGIN WRITE_LONG  0x0a0 exo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~door~ )       AND ( doo >= off ) BEGIN WRITE_LONG  0x0a8 doo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~animation~ )  AND ( ano >= off ) BEGIN WRITE_LONG  0x0b0 ano + size END
		PATCH_IF                                       ( too >= off ) BEGIN WRITE_LONG  0x0b8 too + size END
		PATCH_IF                                       ( soo >= off ) BEGIN WRITE_LONG  0x0bc soo + size END
		PATCH_IF                                       ( reo >= off ) BEGIN WRITE_LONG  0x0c0 reo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~automap~ )    AND ( auo >= off ) BEGIN WRITE_LONG  0x0c4 auo + size END
		PATCH_IF ( ~%type%~ STR_CMP ~projectile~ ) AND ( pro >= off ) BEGIN WRITE_LONG  0x0cc pro + size END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

//BLOCK FC_GET_XY_COORDINATE
DEFINE_PATCH_FUNCTION FC_GET_XY_COORDINATE
	INT_VAR num = 0
	RET     x1 y1
BEGIN
	y1 = ( num >> 16 )
	x1 = num - ( y1 << 16 )
END
//BLOCKEND

//BLOCK FC_UPDATE_VERTEX_INDEX
DEFINE_PATCH_FUNCTION FC_UPDATE_VERTEX_INDEX
	INT_VAR skip = 0 numx = 100000 adds = 100000
	STR_VAR type = trigger //trigger, container, door
BEGIN
	READ_SHORT 0x5a type_cnt
	READ_LONG  0x5c type_off
	PATCH_IF ( type_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < type_cnt ; ++i ) BEGIN
			PATCH_IF ( ~%type%~ STR_EQ ~trigger~ ) AND ( i = skip ) BEGIN END ELSE BEGIN
				READ_LONG type_off + i * 0x0c4 + 0x2c f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c4 + 0x2c f_vert + adds END
			END
		END
	END
	READ_SHORT 0x74 type_cnt
	READ_LONG  0x70 type_off
	PATCH_IF ( type_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < type_cnt ; ++i ) BEGIN
			PATCH_IF ( ~%type%~ STR_EQ ~container~ ) AND ( i = skip ) BEGIN END ELSE BEGIN
				READ_LONG type_off + i * 0x0c0 + 0x50 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c0 + 0x50 f_vert + adds END
			END
		END
	END
	READ_LONG  0xa4 type_cnt
	READ_LONG  0xa8 type_off
	PATCH_IF ( type_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < type_cnt ; ++i ) BEGIN
			PATCH_IF ( ~%type%~ STR_EQ ~door~ ) AND ( i = skip ) BEGIN END ELSE BEGIN
				READ_LONG type_off + i * 0x0c8 + 0x2c f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x2c f_vert + adds END
				READ_LONG type_off + i * 0x0c8 + 0x34 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x34 f_vert + adds END
				READ_LONG type_off + i * 0x0c8 + 0x48 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x48 f_vert + adds END
				READ_LONG type_off + i * 0x0c8 + 0x50 f_vert
				PATCH_IF ( f_vert >= numx ) BEGIN WRITE_LONG type_off + i * 0x0c8 + 0x50 f_vert + adds END
			END
		END
	END
END
//BLOCKEND

//BLOCK FC_EDIT_AREA_DOOR
DEFINE_PATCH_FUNCTION FC_EDIT_AREA_DOOR
	INT_VAR
		flags           = "-1"
		hp              = "-1"
		ac              = "-1"
		cursor_idx      = "-1"
		trap_detect_dif = "-1"
		trap_remove_dif = "-1"
		is_trapped      = "-1"
		is_trap_detect  = "-1"
		launch_x        = "-1"
		launch_y        = "-1"
		detect_diff     = "-1"
		lock_diff       = "-1"
		open_loc_x      = "-1"
		open_loc_y      = "-1"
		close_loc_x     = "-1"
		close_loc_y     = "-1"
		unlock_message  = 99999999
		speaker_name    = 99999999
		//vertex_open_X
		//vertex_closed_X
		//impeded_open_X
		//impeded_closed_X
	STR_VAR
		match_name      = "same"
		match_key       = "same"
		match_script    = "same"
		name            = "same"
		doorId          = "same"
		open_sound      = "same"
		close_sound     = "same"
		key             = "same"
		script          = "same"
		travel_trigger  = "same"
		dialogue        = "same"
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	SET match = 0
	READ_LONG  0x0a4 ~d_cnt~
	READ_LONG  0x0a8 ~d_off~
	PATCH_IF ( is_trapped > 1 )     BEGIN SET is_trapped = 1     END
	PATCH_IF ( is_trap_detect > 1 ) BEGIN SET is_trap_detect = 1 END
	PATCH_IF ( d_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < d_cnt ; ++i ) BEGIN
			SET offset = d_off + i * 0xc8
			PATCH_IF ( ~%match_name%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset d_name (32) NULL
				PATCH_IF ( ~%match_name%~ STR_EQ ~%d_name%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_key%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x78 d_key (8) NULL
				PATCH_IF ( ~%match_key%~ STR_EQ ~%d_key%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_script%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x80 d_scr (8) NULL
				PATCH_IF ( ~%match_script%~ STR_EQ ~%d_scr%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF (match) BEGIN SET door_pos = i SET i = d_cnt SET patch_offset = offset END
		END
	END
	PATCH_IF (match) BEGIN
		PATCH_IF ( ~%name%~           STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset        ~%name%~           (32) END
		PATCH_IF ( ~%doorId%~         STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x20 ~%doorId%~         (8)  END
		PATCH_IF ( ~%flags%~ >= 0 )                    BEGIN WRITE_LONG   patch_offset + 0x28 ~%flags%~               END
		PATCH_IF ( ~%hp%~ >= 0 )                       BEGIN WRITE_SHORT  patch_offset + 0x54 ~%hp%~                  END
		PATCH_IF ( ~%ac%~ >= 0 )                       BEGIN WRITE_SHORT  patch_offset + 0x56 ~%ac%~                  END
		PATCH_IF ( ~%open_sound%~     STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x58 ~%open_sound%~     (8)  END
		PATCH_IF ( ~%close_sound%~    STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x60 ~%close_sound%~    (8)  END
		PATCH_IF ( ~%cursor_idx%~ >= 0 )               BEGIN WRITE_LONG   patch_offset + 0x68 ~%cursor_idx%~          END
		PATCH_IF ( ~%trap_detect_dif%~ >= 0 )          BEGIN WRITE_SHORT  patch_offset + 0x6c ~%trap_detect_dif%~     END
		PATCH_IF ( ~%trap_remove_dif%~ >= 0 )          BEGIN WRITE_SHORT  patch_offset + 0x6e ~%trap_remove_dif%~     END
		PATCH_IF ( ~%is_trapped%~ >= 0 )               BEGIN WRITE_SHORT  patch_offset + 0x70 ~%is_trapped%~          END
		PATCH_IF ( ~%is_trap_detect%~ >= 0 )           BEGIN WRITE_SHORT  patch_offset + 0x72 ~%is_trap_detect%~      END
		PATCH_IF ( ~%launch_x%~ >= 0 )                 BEGIN WRITE_SHORT  patch_offset + 0x74 ~%launch_x%~            END
		PATCH_IF ( ~%launch_y%~ >= 0 )                 BEGIN WRITE_SHORT  patch_offset + 0x76 ~%launch_y%~            END
		PATCH_IF ( ~%key%~            STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x78 ~%key%~            (8)  END
		PATCH_IF ( ~%script%~         STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x80 ~%script%~         (8)  END
		PATCH_IF ( ~%detect_diff%~ >= 0 )              BEGIN WRITE_LONG   patch_offset + 0x88 ~%detect_diff%~         END
		PATCH_IF ( ~%lock_diff%~ >= 0 )                BEGIN WRITE_LONG   patch_offset + 0x8c ~%lock_diff%~           END
		PATCH_IF ( ~%open_loc_x%~ >= 0 )               BEGIN WRITE_SHORT  patch_offset + 0x90 ~%open_loc_x%~          END
		PATCH_IF ( ~%open_loc_y%~ >= 0 )               BEGIN WRITE_SHORT  patch_offset + 0x92 ~%open_loc_y%~          END
		PATCH_IF ( ~%close_loc_x%~ >= 0 )              BEGIN WRITE_SHORT  patch_offset + 0x94 ~%close_loc_x%~         END
		PATCH_IF ( ~%close_loc_y%~ >= 0 )              BEGIN WRITE_SHORT  patch_offset + 0x96 ~%close_loc_y%~         END
		PATCH_IF ( ~%unlock_message%~ != 99999999 )    BEGIN WRITE_LONG   patch_offset + 0x98 ~%unlock_message%~      END
		PATCH_IF ( ~%travel_trigger%~ STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x9c ~%travel_trigger%~ (24) END
		PATCH_IF ( ~%speaker_name%~   != 99999999 )    BEGIN WRITE_LONG   patch_offset + 0xb4 ~%speaker_name%~        END
		PATCH_IF ( ~%dialogue%~       STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0xb8 ~%dialogue%~       (8)  END
		//vertex_open_X
		PATCH_IF ( VARIABLE_IS_SET $vertex_open(0) ) BEGIN
			READ_LONG  patch_offset + 0x2c vertex_first
			READ_SHORT patch_offset + 0x30 vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex_open(~%i%~) ) BEGIN
					SET v_num = $vertex_open(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x30 num_v
			WRITE_SHORT patch_offset + 0x38 x_bounding_left
			WRITE_SHORT patch_offset + 0x3a x_bounding_top
			WRITE_SHORT patch_offset + 0x3c x_bounding_right
			WRITE_SHORT patch_offset + 0x3e x_bounding_bottom
			READ_LONG   patch_offset + 0x34 upd_vert_1
			READ_LONG   patch_offset + 0x48 upd_vert_2
			READ_LONG   patch_offset + 0x50 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x34 upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x48 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x50 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex_open
		END
		//vertex_closed_X
		 PATCH_IF ( VARIABLE_IS_SET $vertex_closed(0) ) BEGIN
			READ_LONG  patch_offset + 0x34 vertex_first
			READ_SHORT patch_offset + 0x32 vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex_closed(~%i%~) ) BEGIN
					SET v_num = $vertex_closed(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x32 num_v
			WRITE_SHORT patch_offset + 0x40 x_bounding_left
			WRITE_SHORT patch_offset + 0x42 x_bounding_top
			WRITE_SHORT patch_offset + 0x44 x_bounding_right
			WRITE_SHORT patch_offset + 0x46 x_bounding_bottom
			READ_LONG   patch_offset + 0x2c upd_vert_1
			READ_LONG   patch_offset + 0x48 upd_vert_2
			READ_LONG   patch_offset + 0x50 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x2c upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x48 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x50 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex_closed
		END
		//impeded_open_X
		PATCH_IF ( VARIABLE_IS_SET $impeded_open(0) ) BEGIN
			READ_LONG  patch_offset + 0x48 vertex_first
			READ_SHORT patch_offset + 0x4c vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $impeded_open(~%i%~) ) BEGIN
					SET v_num = $impeded_open(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x4c num_v
			READ_LONG   patch_offset + 0x2c upd_vert_1
			READ_LONG   patch_offset + 0x34 upd_vert_2
			READ_LONG   patch_offset + 0x50 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x2c upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x34 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x50 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY impeded_open
		END
		//impeded_closed_X
		PATCH_IF ( VARIABLE_IS_SET $impeded_closed(0) ) BEGIN
			READ_LONG  patch_offset + 0x50 vertex_first
			READ_SHORT patch_offset + 0x4e vertex_cnt
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $impeded_closed(~%i%~) ) BEGIN
					SET v_num = $impeded_closed(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x4e num_v
			READ_LONG   patch_offset + 0x2c upd_vert_1
			READ_LONG   patch_offset + 0x34 upd_vert_2
			READ_LONG   patch_offset + 0x48 upd_vert_3
			PATCH_IF ( upd_vert_1 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x2c upd_vert_1 + deleted_vertex END
			PATCH_IF ( upd_vert_2 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x34 upd_vert_2 + deleted_vertex END
			PATCH_IF ( upd_vert_3 >= vertex_first ) BEGIN WRITE_LONG patch_offset + 0x48 upd_vert_3 + deleted_vertex END
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = door
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY impeded_closed
		END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

//BLOCK FC_EDIT_AREA_REGION
DEFINE_PATCH_FUNCTION FC_EDIT_AREA_REGION
	INT_VAR
		region_type     = "-1"
		trigger_value   = "-1"
		cursor_idx      = "-1"
		flags           = "-1"
		info_text       = 99999999
		trap_detect_dif = "-1"
		trap_remove_dif = "-1"
		is_trapped      = "-1"
		is_trap_detect  = "-1"
		launch_x        = "-1"
		launch_y        = "-1"
		alt_point_x     = "-1"
		alt_point_y     = "-1"
		//vertex_X
	STR_VAR
		match_name      = "same"
		match_key       = "same"
		match_script    = "same"
		name            = "same"
		dest_area       = "same"
		entrance        = "same"
		key             = "same"
		script          = "same"
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	SET match = 0
	READ_SHORT 0x05a ~d_cnt~
	READ_LONG  0x05c ~d_off~
	PATCH_IF ( region_type > 2 )    BEGIN SET region_type = 1    END
	PATCH_IF ( is_trapped > 1 )     BEGIN SET is_trapped = 1     END
	PATCH_IF ( is_trap_detect > 1 ) BEGIN SET is_trap_detect = 1 END
	PATCH_IF ( d_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < d_cnt ; ++i ) BEGIN
			SET offset = d_off + i * 0xc4
			PATCH_IF ( ~%match_name%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset d_name (32) NULL
				PATCH_IF ( ~%match_name%~ STR_EQ ~%d_name%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_key%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x74 d_key (8) NULL
				PATCH_IF ( ~%match_key%~ STR_EQ ~%d_key%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_script%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x7c d_scr (8) NULL
				PATCH_IF ( ~%match_script%~ STR_EQ ~%d_scr%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF (match) BEGIN SET door_pos = i SET i = d_cnt SET patch_offset = offset END
		END
	END
	PATCH_IF (match) BEGIN
		PATCH_IF ( ~%name%~      STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset        ~%name%~       (32) END
		PATCH_IF ( ~%region_type%~ >= 0 )         BEGIN WRITE_SHORT  patch_offset + 0x20 ~%region_type%~     END
		PATCH_IF ( ~%trigger_value%~ >= 0 )       BEGIN WRITE_LONG   patch_offset + 0x30 ~%trigger_value%~   END
		PATCH_IF ( ~%cursor_idx%~ >= 0 )          BEGIN WRITE_LONG   patch_offset + 0x34 ~%cursor_idx%~      END
		PATCH_IF ( ~%dest_area%~ STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x38 ~%dest_area%~  (8)  END
		PATCH_IF ( ~%entrance%~  STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x40 ~%entrance%~   (32) END
		PATCH_IF ( ~%flags%~ >= 0 )               BEGIN WRITE_LONG   patch_offset + 0x60 ~%flags%~           END
		PATCH_IF ( ~%info_text%~ != 99999999 )    BEGIN WRITE_LONG   patch_offset + 0x64 ~%info_text%~       END
		PATCH_IF ( ~%trap_detect_dif%~ >= 0 )     BEGIN WRITE_SHORT  patch_offset + 0x68 ~%trap_detect_dif%~ END
		PATCH_IF ( ~%trap_remove_dif%~ >= 0 )     BEGIN WRITE_SHORT  patch_offset + 0x6a ~%trap_remove_dif%~ END
		PATCH_IF ( ~%is_trapped%~ >= 0 )          BEGIN WRITE_SHORT  patch_offset + 0x6c ~%is_trapped%~      END
		PATCH_IF ( ~%is_trap_detect%~ >= 0 )      BEGIN WRITE_SHORT  patch_offset + 0x6e ~%is_trap_detect%~  END
		PATCH_IF ( ~%launch_x%~ >= 0 )            BEGIN WRITE_SHORT  patch_offset + 0x70 ~%launch_x%~        END
		PATCH_IF ( ~%launch_y%~ >= 0 )            BEGIN WRITE_SHORT  patch_offset + 0x72 ~%launch_y%~        END
		PATCH_IF ( ~%key%~       STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x74 ~%key%~        (8)  END
		PATCH_IF ( ~%script%~    STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x7c ~%script%~     (8)  END
		PATCH_IF ( ~%alt_point_x%~ >= 0 )         BEGIN WRITE_SHORT  patch_offset + 0x84 ~%alt_point_x%~     END
		PATCH_IF ( ~%alt_point_y%~ >= 0 )         BEGIN WRITE_SHORT  patch_offset + 0x86 ~%alt_point_y%~     END
		PATCH_IF ( VARIABLE_IS_SET $vertex(0) ) BEGIN
			READ_SHORT patch_offset + 0x2a vertex_cnt
			READ_LONG  patch_offset + 0x2c vertex_first
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex(~%i%~) ) BEGIN
					SET v_num = $vertex(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x2a num_v
			WRITE_SHORT patch_offset + 0x22 x_bounding_left
			WRITE_SHORT patch_offset + 0x24 x_bounding_top
			WRITE_SHORT patch_offset + 0x26 x_bounding_right
			WRITE_SHORT patch_offset + 0x28 x_bounding_bottom
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = trigger
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex
		END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

//BLOCK FC_EDIT_AREA_CONTAINER
DEFINE_PATCH_FUNCTION FC_EDIT_AREA_CONTAINER
	INT_VAR
		loc_x           = "-1"
		loc_y           = "-1"
		type            = "-1"
		lock_diff       = "-1"
		flags           = "-1"
		trap_detect_dif = "-1"
		trap_remove_dif = "-1"
		is_trapped      = "-1"
		is_trap_detect  = "-1"
		launch_x        = "-1"
		launch_y        = "-1"
		active_range    = "-1"
		break_diff      = "-1"
		lpick_text      = 99999999
		//vertex_X
	STR_VAR
		match_name      = "same"
		match_key       = "same"
		match_script    = "same"
		match_owner     = "same"
		name            = "same"
		script          = "same"
		owner           = "same"
		key             = "same"
	RET
		done
BEGIN
	//BLOCK 
	SET done = 0
	SET match = 0
	READ_SHORT 0x074 ~d_cnt~
	READ_LONG  0x070 ~d_off~
	PATCH_IF ( type > 12 )          BEGIN SET type           = 4 END
	PATCH_IF ( is_trapped > 1 )     BEGIN SET is_trapped     = 1 END
	PATCH_IF ( is_trap_detect > 1 ) BEGIN SET is_trap_detect = 1 END /* */
	PATCH_IF ( d_cnt > 0 ) BEGIN
		FOR ( i = 0 ; i < d_cnt ; ++i ) BEGIN
			SET offset = d_off + i * 0xc0
			PATCH_IF ( ~%match_name%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset d_name (32) NULL
				PATCH_IF ( ~%match_name%~ STR_EQ ~%d_name%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_key%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x78 d_key (8) NULL
				PATCH_IF ( ~%match_key%~ STR_EQ ~%d_key%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_script%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x48 d_scr (8) NULL
				PATCH_IF ( ~%match_script%~ STR_EQ ~%d_scr%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF ( ~%match_owner%~ STR_CMP ~same~ ) BEGIN
				READ_ASCII offset + 0x58 d_owner (32) NULL
				PATCH_IF ( ~%match_owner%~ STR_EQ ~%d_owner%~ ) BEGIN SET match = 1 END ELSE BEGIN SET match = 0 END
			END
			PATCH_IF (match) BEGIN SET door_pos = i SET i = d_cnt SET patch_offset = offset END
		END
	END
	PATCH_IF (match) BEGIN
		PATCH_IF ( ~%name%~      STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset        ~%name%~       (32) END
		PATCH_IF ( ~%loc_x%~ >= 0               ) BEGIN WRITE_SHORT  patch_offset + 0x20 ~%loc_x%~           END
		PATCH_IF ( ~%loc_y%~ >= 0               ) BEGIN WRITE_SHORT  patch_offset + 0x22 ~%loc_y%~           END
		PATCH_IF ( ~%type%~  >= 1               ) BEGIN WRITE_SHORT  patch_offset + 0x24 ~%type%~            END
		PATCH_IF ( ~%lock_diff%~ >= 0           ) BEGIN WRITE_SHORT  patch_offset + 0x26 ~%lock_diff%~       END
		PATCH_IF ( ~%flags%~ >= 0               ) BEGIN WRITE_LONG   patch_offset + 0x28 ~%flags%~           END
		PATCH_IF ( ~%trap_detect_dif%~ >= 0     ) BEGIN WRITE_SHORT  patch_offset + 0x2c ~%trap_detect_dif%~ END
		PATCH_IF ( ~%trap_remove_dif%~ >= 0     ) BEGIN WRITE_SHORT  patch_offset + 0x2e ~%trap_remove_dif%~ END
		PATCH_IF ( ~%is_trapped%~ >= 0          ) BEGIN WRITE_SHORT  patch_offset + 0x30 ~%is_trapped%~      END
		PATCH_IF ( ~%is_trap_detect%~ >= 0      ) BEGIN WRITE_SHORT  patch_offset + 0x32 ~%is_trap_detect%~  END
		PATCH_IF ( ~%launch_x%~ >= 0            ) BEGIN WRITE_SHORT  patch_offset + 0x34 ~%launch_x%~        END
		PATCH_IF ( ~%launch_y%~ >= 0            ) BEGIN WRITE_SHORT  patch_offset + 0x36 ~%launch_y%~        END
		PATCH_IF ( ~%script%~    STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x48 ~%script%~      (8) END
		PATCH_IF ( ~%active_range%~ >= 0        ) BEGIN WRITE_SHORT  patch_offset + 0x56 ~%active_range%~    END
		PATCH_IF ( ~%owner%~     STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x58 ~%owner%~      (32) END
		PATCH_IF ( ~%key%~       STR_CMP ~same~ ) BEGIN WRITE_ASCIIE patch_offset + 0x78 ~%key%~         (8) END
		PATCH_IF ( ~%break_diff%~ >= 0          ) BEGIN WRITE_LONG   patch_offset + 0x80 ~%break_diff%~      END
		PATCH_IF ( ~%lpick_text%~ !=   99999999 ) BEGIN WRITE_LONG   patch_offset + 0x84 ~%lpick_text%~      END
		PATCH_IF ( VARIABLE_IS_SET $vertex(0) ) BEGIN
			READ_SHORT patch_offset + 0x54 vertex_cnt
			READ_LONG  patch_offset + 0x50 vertex_first
			SET deleted_vertex = 0 - vertex_cnt
			READ_LONG  0x7c all_vertex_off
			READ_SHORT 0x80 all_vertex_cnt
			SET v_off = all_vertex_off + vertex_first * 0x004
			SET num_v = 0
			DELETE_BYTES v_off vertex_cnt * 0x004
			SET x_bounding_left = 10000
			SET x_bounding_top  = 10000
			SET x_bounding_right  = 0
			SET x_bounding_bottom = 0
			FOR ( i = 0 ; i < 65535 ; ++i ) BEGIN
				PATCH_IF ( VARIABLE_IS_SET $vertex(~%i%~) ) BEGIN
					SET v_num = $vertex(~%i%~)
					INSERT_BYTES v_off + i * 0x004 0x004
					WRITE_LONG   v_off + i * 0x004 v_num
					LPF FC_GET_XY_COORDINATE INT_VAR num = v_num RET x1 y1 END
					PATCH_IF ( x_bounding_left   > x1 ) BEGIN SET x_bounding_left   = x1 END
					PATCH_IF ( x_bounding_top    > y1 ) BEGIN SET x_bounding_top    = y1 END
					PATCH_IF ( x_bounding_right  < x1 ) BEGIN SET x_bounding_right  = x1 END
					PATCH_IF ( x_bounding_bottom < y1 ) BEGIN SET x_bounding_bottom = y1 END
					SET deleted_vertex = deleted_vertex + 1
					SET num_v = num_v + 1
				END ELSE BEGIN SET i = 65535 END
			END
			WRITE_SHORT 0x80 all_vertex_cnt + deleted_vertex
			WRITE_SHORT patch_offset + 0x54 num_v
			WRITE_SHORT patch_offset + 0x38 x_bounding_left
			WRITE_SHORT patch_offset + 0x3a x_bounding_top
			WRITE_SHORT patch_offset + 0x3c x_bounding_right
			WRITE_SHORT patch_offset + 0x3e x_bounding_bottom
			LPF FC_UPDATE_VERTEX_INDEX
				INT_VAR skip = door_pos numx = vertex_first adds = deleted_vertex
				STR_VAR type = container
			END
			LPF FC_UPDETE_AREA_OFFSETS INT_VAR num = deleted_vertex STR_VAR type = vertex END
			CLEAR_ARRAY vertex
		END
		SET done = 1
	END
	//BLOCKEND
END
//BLOCKEND

//BLOCK DLG_FUNCTIONS
// ѕример:
//OUTER_SPRINT ~ssstr~ ~Ќова€ строка это~ //ћожно @XXX, а можно несколько реплик дл€ разных героев через переменные
//LAF FC_APPEND_TO_DLGS
//	INT_VAR
//		state_to_patch = 26 //номер State куда это дело надо добавить
//	STR_VAR
//		dlg = "EDWIN" // им€ dlg файла
//		str = EVAL ~%ssstr%~ // реплика персонажа (переменна€ может быть любой) *
//END
DEFINE_ACTION_FUNCTION FC_COMPILE_EXTERNAL_DLG
	INT_VAR
		lbl  = "-1"
		nlbl = "-1"
	STR_VAR
		dlg_patch = ""
		dlg_orig  = ""
		string    = ""
BEGIN
<<<<<<<< inl_dlg.d
ALTER_TRANS %dlg_patch% BEGIN %nlbl% END BEGIN 0 END BEGIN "EPILOGUE" ~EXTERN %dlg_orig% XXX1~ END

CHAIN
IF ~~ THEN %dlg_orig% XXX1
  ~%string%~
END %dlg_orig% %lbl%
>>>>>>>>
	COMPILE ~inl_dlg.d~ EVALUATE_BUFFER
END

DEFINE_ACTION_FUNCTION FC_APPEND_TO_DLGS
	INT_VAR
		state_to_patch = "-1"
	STR_VAR
		dlg = ""
		str = ""
BEGIN
	ACTION_CLEAR_ARRAY STATE_LABEL_ARRAY
	ACTION_IF FILE_EXISTS_IN_GAME ~%dlg%.dlg~ BEGIN
		COPY_EXISTING ~%dlg%.dlg~ ~override~
			READ_LONG 0x08      state_num
			READ_LONG 0x0c      state_off
			SET       n_state = "-1"
			PATCH_IF ( state_num > %state_to_patch% ) BEGIN
				SET       offset =     state_off + ~%state_to_patch%~ * 0x10
				READ_LONG offset   + 0x4 resp_fst
				READ_LONG offset   + 0x8 resp_cnt
				READ_LONG 0x10           resp_num
				READ_LONG 0x14           resp_off
				SET       resp_all =     resp_fst + resp_cnt
				PATCH_IF  ( resp_num >= resp_all ) BEGIN
					FOR ( i = resp_fst ; i < resp_all ; ++i ) BEGIN
						SET        off2 = resp_off + i * 0x20
						READ_ASCII off2 + 0x14       d_name (8) NULL
						READ_LONG  off2 + 0x1c       idx
						PATCH_IF ( n_state < 0 ) BEGIN
							SET n_state = idx
							SET idx     = state_to_patch
						END
						DEFINE_ASSOCIATIVE_ARRAY STATE_LABEL_ARRAY BEGIN
							~%dlg%~, ~%d_name%~, ~%str%~, ~%n_state%~, ~%idx%~ => ~~
						END
					END
				END
			END
			BUT_ONLY_IF_IT_CHANGES
		ACTION_PHP_EACH STATE_LABEL_ARRAY AS slb => _ BEGIN
			LAF FC_COMPILE_EXTERNAL_DLG
				INT_VAR
					lbl       =      "%slb_3%"
					nlbl      =      "%slb_4%"
				STR_VAR
					dlg_patch = EVAL "%slb_1%"
					dlg_orig  = EVAL "%slb%"
					string    = EVAL "%slb_2%"
			END
		END
	END
END
//BLOCKEND

//BLOCK  ATTACK_PER_ROUND
DEFINE_PATCH_FUNCTION ADD_ATTACK_PER_ROUND
	INT_VAR
		mode     = 1 //!0 - plus, 0 - minus
		attacks  = "-1" // <0 - automate read
		not_zero = 1 //!0 - not APR=0, 0 - allow APR=0
		write    = 1 // 0 - only return RES, !0 - return RES and write APR
	STR_VAR
		adds     = "1.0" //0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0
	RET
		attacks
BEGIN
	PATCH_IF ( attacks < 0 ) BEGIN SET attacks = ( BYTE_AT 0x53 ) END
	INNER_PATCH_SAVE ~adds~ ~%adds%~ BEGIN
		REPLACE_TEXTUALLY ~,~ ~.~
	END
	SET att  = attacks
	SET atts = 0
	SET no_patch = 0
	PATCH_IF ( mode     != 0 ) BEGIN SET mode     = 1 END
	PATCH_IF ( not_zero != 0 ) BEGIN SET not_zero = 1 END
	PATCH_IF ( write    != 0 ) BEGIN SET write    = 1 END
	PATCH_IF ( att > 10 ) OR  ( att < 0 )  BEGIN SET no_patch = 1 END
	PATCH_IF ( NOT no_patch ) BEGIN
		PATCH_MATCH att WITH
			0  BEGIN SET atts = 0  END
			1  BEGIN SET atts = 10 END
			2  BEGIN SET atts = 20 END
			3  BEGIN SET atts = 30 END
			4  BEGIN SET atts = 40 END
			5  BEGIN SET atts = 50 END
			6  BEGIN SET atts = 5  END
			7  BEGIN SET atts = 15 END
			8  BEGIN SET atts = 25 END
			9  BEGIN SET atts = 35 END
			10 BEGIN SET atts = 45 END
		DEFAULT
		END
		PATCH_IF ( mode ) BEGIN SET zxxx = 1 END ELSE BEGIN SET zxxx = ( 0 - 1 ) END
		PATCH_MATCH ~%adds%~ WITH
			"0.0" BEGIN SET atts = atts +  0        END
			"0.5" BEGIN SET atts = atts +  5 * zxxx END
			"1.0" BEGIN SET atts = atts + 10 * zxxx END
			"1.5" BEGIN SET atts = atts + 15 * zxxx END
			"2.0" BEGIN SET atts = atts + 20 * zxxx END
			"2.5" BEGIN SET atts = atts + 25 * zxxx END
			"3.0" BEGIN SET atts = atts + 30 * zxxx END
			"3.5" BEGIN SET atts = atts + 35 * zxxx END
			"4.0" BEGIN SET atts = atts + 40 * zxxx END
			"4.5" BEGIN SET atts = atts + 45 * zxxx END
			"5.0" BEGIN SET atts = atts + 50 * zxxx END
		DEFAULT
		END
		PATCH_IF ( atts > 50 )                 BEGIN SET atts = 50 END
		PATCH_IF ( atts <  0 )                 BEGIN SET atts =  0 END
		PATCH_IF ( not_zero ) AND ( atts = 0 ) BEGIN SET atts =  5 END
		PATCH_MATCH atts WITH
			0  BEGIN SET att =  0 END
			5  BEGIN SET att =  6 END
			10 BEGIN SET att =  1 END
			15 BEGIN SET att =  7 END
			20 BEGIN SET att =  2 END
			25 BEGIN SET att =  8 END
			30 BEGIN SET att =  3 END
			35 BEGIN SET att =  9 END
			40 BEGIN SET att =  4 END
			45 BEGIN SET att = 10 END
			50 BEGIN SET att =  5 END
		DEFAULT
		END
	END
	SET attacks = att
	PATCH_IF ( write ) BEGIN
		WRITE_BYTE 0x53 attacks
	END
END
//BLOCKEND

//BLOCK FC_EDIT_SAVING_THROW
DEFINE_PATCH_FUNCTION FC_EDIT_SAVING_THROW
	INT_VAR
		mode   = 1 //1 - better, 0 - worse
		all    = 0 //all saves
		death  = 0
		wand   = 0
		poly   = 0
		breath = 0
		spell  = 0
BEGIN
	PATCH_IF ( mode != 0 ) BEGIN SET mode = 1 END ELSE BEGIN SET mode = ( 0 - 1 ) END
	PATCH_IF ( all > 0 ) BEGIN
		SET death  = all
		SET wand   = all
		SET poly   = all
		SET breath = all
		SET spell  = all
	END
	PATCH_IF ( death  > 0 ) BEGIN WRITE_BYTE 0x54 ( THIS - ( death  * mode ) ) END
	PATCH_IF ( wand   > 0 ) BEGIN WRITE_BYTE 0x55 ( THIS - ( wand   * mode ) ) END
	PATCH_IF ( poly   > 0 ) BEGIN WRITE_BYTE 0x56 ( THIS - ( poly   * mode ) ) END
	PATCH_IF ( breath > 0 ) BEGIN WRITE_BYTE 0x57 ( THIS - ( breath * mode ) ) END
	PATCH_IF ( spell  > 0 ) BEGIN WRITE_BYTE 0x58 ( THIS - ( spell  * mode ) ) END
END
//BLOCKEND

//BLOCK EDIT_STORE_PURCHASE
DEFINE_PATCH_FUNCTION EDIT_STORE_PURCHASE
	INT_VAR
		type   = "-1"
		delete =   0
BEGIN
	SET add =   0
	SET ix  = "-1"
	SET off =   0
	PATCH_IF ( delete != 0 ) BEGIN SET delete = 1 SET ix = 1 END
	PATCH_IF ( type   >= 0 ) BEGIN
		READ_LONG 0x2c purch_off
		READ_LONG 0x30 purch_num
		SET add = 1
		PATCH_IF ( purch_num > 0 ) BEGIN
			FOR ( i = 0 ; i < purch_num ; ++i ) BEGIN
				READ_LONG purch_off + i * 4 tp
				PATCH_IF ( tp = type ) BEGIN
					SET i = purch_num
					PATCH_IF ( delete ) BEGIN
						SET off = i * 4
					END ELSE BEGIN
						SET add = 0
					END
				END
			END
		END
	END
	PATCH_IF ( add ) BEGIN
		READ_LONG    0x34 items_off
		READ_LONG    0x4c drink_off
		READ_LONG    0x70 cures_off
		PATCH_IF ( delete ) BEGIN
			DELETE_BYTES purch_off + off           4
			PATCH_IF ( items_off >  purch_off ) BEGIN WRITE_LONG 0x34 ( items_off - 4 ) END
			PATCH_IF ( drink_off >  purch_off ) BEGIN WRITE_LONG 0x34 ( drink_off - 4 ) END
			PATCH_IF ( cures_off >  purch_off ) BEGIN WRITE_LONG 0x34 ( cures_off - 4 ) END
		END ELSE BEGIN
			INSERT_BYTES purch_off + purch_num * 4 4
			WRITE_LONG   purch_off + purch_num * 4 type
			PATCH_IF ( items_off >= purch_off ) BEGIN WRITE_LONG 0x34 ( items_off + 4 ) END
			PATCH_IF ( drink_off >= purch_off ) BEGIN WRITE_LONG 0x34 ( drink_off + 4 ) END
			PATCH_IF ( cures_off >= purch_off ) BEGIN WRITE_LONG 0x34 ( cures_off + 4 ) END
		END
		WRITE_LONG   0x30 ( purch_num + ( 1 * ix ) )
	END
END
//BLOCKEND

//BLOCK ADD_ITEM_DIALOG
// Adds a new entry for a conversable item
DEFINE_PATCH_FUNCTION ADD_ITEM_DIALOG
	INT_VAR
		button_strref = 5689  // Default: "Converse"
		name_strref   = "-1"  // not used outside of PSTEE
	STR_VAR
		itm_resref    = ~~
		dlg_resref    = ~~
BEGIN
	PATCH_IF (NOT ~%itm_resref%~ STR_EQ ~~) BEGIN
		PATCH_IF (~%dlg_resref%~ STR_EQ ~~) BEGIN TEXT_SPRINT dlg_resref ~%itm_resref%~ END
		COUNT_2DA_COLS numCols
		COUNT_2DA_ROWS numCols numRows
		TEXT_SPRINT entry ~%itm_resref%      %button_strref%  %dlg_resref%~
		PATCH_IF (numCols > 3) BEGIN
			TEXT_SPRINT entry ~%entry% %name_strref%~
			FOR (idx = 4; idx < numCols; ++idx) BEGIN TEXT_SPRINT entry ~%entry% *~ END
		END
		INSERT_2DA_ROW numRows numCols ~%entry%~
	END
END
//BLOCKEND

//BLOCK COPY_TIS_PVRZ
DEFINE_ACTION_FUNCTION FC_COPY_TIS_PVRZ
	INT_VAR
		delete_original=0 // 1 - delete original pvrz
	STR_VAR
		tis_pvrz_path = ""
		path_to_vanilla_tis = "" // using if Not find free pvrz index
		tis_name = "" // original tis-name
		tis_name_target = "" // target tis-name. if tis_name_target = "" => tis_name_target = tis_name
		target_path = "override"
BEGIN
	ACTION_IF ( ~%tis_name_target%~ STR_EQ ~~ ) BEGIN OUTER_SPRINT tis_name_target ~%tis_name%~ END
	
	ACTION_CLEAR_ARRAY FC_PVRZ_PAGE_ARRAY
	ACTION_CLEAR_ARRAY FC_OFFSET_ARRAY
	
	OUTER_PATCH_SAVE pvr_name_old ~%tis_name%~ BEGIN
		DELETE_BYTES 1 1
	END
	OUTER_PATCH_SAVE pvr_name ~%tis_name_target%~ BEGIN
		DELETE_BYTES 1 1
	END
	
	OUTER_SET original = 0
	
	ACTION_IF ( FILE_EXISTS ~%tis_pvrz_path%/%tis_name%.tis~ ) BEGIN
		COPY ~%tis_pvrz_path%/%tis_name%.tis~ ~%target_path%/%tis_name_target%.tis~
			READ_LONG 0x8  "tiles_cnt"
			READ_LONG 0x10 "tiles_off"
			READ_LONG 0xc  "tiles_length"
			SET x = 0
			SET z = 0
			FOR ( i = 0 ; i < tiles_cnt ; ++i ) BEGIN
				SET offset = tiles_off + tiles_length * i
				READ_LONG offset pvr_pg
				DEFINE_ASSOCIATIVE_ARRAY FC_OFFSET_ARRAY BEGIN ~%offset%~ => ~%pvr_pg%~ END
				PATCH_IF !( VARIABLE_IS_SET $FC_PVRZ_PAGE_ARRAY( ~%pvr_pg%~ ) ) BEGIN
					PATCH_IF ( pvr_pg < 10 ) BEGIN SPRINT pgi ~0%pvr_pg%~ END ELSE BEGIN SPRINT pgi ~%pvr_pg%~ END
					PATCH_IF ( NOT FILE_EXISTS_IN_GAME ~%pvr_name%%pgi%.PVRZ~ ) BEGIN
						SET z = pvr_pg
						DEFINE_ASSOCIATIVE_ARRAY FC_PVRZ_PAGE_ARRAY BEGIN ~%pvr_pg%~ => ~%z%~    END
					END ELSE BEGIN
						SET z = z + 1
						FOR ( j = z ; j < 100 ; ++j ) BEGIN
							PATCH_IF ( z < 10 ) BEGIN SPRINT pgi ~0%z%~ END ELSE BEGIN SPRINT pgi ~%z%~ END
							PATCH_IF ( NOT FILE_EXISTS_IN_GAME ~%pvr_name%%pgi%.PVRZ~ ) BEGIN
								DEFINE_ASSOCIATIVE_ARRAY FC_PVRZ_PAGE_ARRAY BEGIN ~%pvr_pg%~ => ~%j%~    END
								SET j = 100
							END ELSE BEGIN
								SET z = z + 1
							END
						END
					END
				END
			END
			PATCH_IF ( z > 99 ) BEGIN SET original = 1 END
			PHP_EACH FC_OFFSET_ARRAY AS offset => value BEGIN
				SET new_value = 0
				PATCH_IF ( VARIABLE_IS_SET $FC_PVRZ_PAGE_ARRAY( ~%value%~ ) ) BEGIN
					SET new_value = $FC_PVRZ_PAGE_ARRAY( ~%value%~ )
				END
				WRITE_LONG ~%offset%~ ~%new_value%~
			END
		
		ACTION_IF ( delete_original ) BEGIN
			DELETE ~%tis_pvrz_path%/%tis_name%.tis~
		END

		ACTION_IF ( NOT original ) BEGIN
			ACTION_PHP_EACH FC_PVRZ_PAGE_ARRAY AS source => dest BEGIN
				ACTION_IF ( source < 10 ) BEGIN OUTER_SPRINT sourceX ~0%source%~ END ELSE BEGIN OUTER_SPRINT sourceX ~%source%~ END
				ACTION_IF ( dest   < 10 ) BEGIN OUTER_SPRINT destX   ~0%dest%~   END ELSE BEGIN OUTER_SPRINT destX   ~%dest%~   END
				ACTION_IF ( FILE_EXISTS ~%tis_pvrz_path%/%pvr_name_old%%sourceX%.PVRZ~ ) BEGIN
					PRINT ~%pvr_name_old%%sourceX%.PVRZ => %target_path%/%pvr_name%%destX%.PVRZ~
					SILENT
						COPY ~%tis_pvrz_path%/%pvr_name_old%%sourceX%.PVRZ~ ~%target_path%/%pvr_name%%destX%.PVRZ~
						ACTION_IF ( delete_original ) BEGIN
							DELETE ~%tis_pvrz_path%/%pvr_name_old%%sourceX%.PVRZ~
						END
					VERBOSE
				END
			END
		END ELSE BEGIN
			PRINT ~Not find free PVRZ index...~
			ACTION_IF ( ~%path_to_vanilla_tis%~ STR_CMP ~~ ) BEGIN
				ACTION_IF ( FILE_EXISTS ~%path_to_vanilla_tis%/%tis_name%.tis~ ) BEGIN
					PRINT ~Using vanilla TIS...~
					COPY ~%path_to_vanilla_tis%/%tis_name%.tis~ ~%target_path%/%tis_name_target%.tis~
				END
			END
		END
	END
END
//BLOCKEND



















